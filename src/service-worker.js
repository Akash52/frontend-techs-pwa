import { build, files } from '$service-worker';

const worker = self;
const STATIC_CACHE_NAME = 'cache-v1';
const APP_CACHE_NAME = 'offline-v1';
const CACHE_NAMES = [STATIC_CACHE_NAME, APP_CACHE_NAME];
const version = 'v1';

// hard-coded list of app routes we want to preemptively cache
const routes = ['/'];

// hard-coded list of other assets necessary for page load outside our domain
const customAssets = ['https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap'];

// `build` is an array of all the files generated by the bundler,
const addOrigin = (assets) => assets.map((asset) => `${self.location.origin}${asset}`);

// Filter out logos for iOS and add origin to assets
const ourAssets = addOrigin([
	...files.filter((file) => !/\/icons\/(apple.*?|original.png)/.test(file)),
	...build,
	...routes
]);

// Combine our assets and custom assets to be pre-cached
const toCache = [...ourAssets, ...customAssets];

async function cacheStaticAssets() {
	const cache = await caches.open(STATIC_CACHE_NAME);
	await cache.addAll(toCache);
}

async function deleteOldCaches() {
	const keys = await caches.keys();
	return Promise.all(
		keys.filter((key) => !CACHE_NAMES.includes(key)).map((key) => caches.delete(key))
	);
}

async function activateServiceWorker() {
	await deleteOldCaches();
	await self.clients.claim();
}

worker.addEventListener('install', (event) => {
	event.waitUntil(cacheStaticAssets());
});

worker.addEventListener('activate', (event) => {
	event.waitUntil(activateServiceWorker());
});

// Handle requests from the cache if available, otherwise fetch them
async function serve(request) {
	const cache = await caches.open(APP_CACHE_NAME);
	const cachedResponse = await cache.match(request);

	if (cachedResponse) {
		return cachedResponse;
	}

	try {
		const networkResponse = await fetch(request);

		// Cache successful network responses
		if (networkResponse.ok) {
			cache.put(request, networkResponse.clone());
		}

		return networkResponse;
	} catch (error) {
		throw new Error(`Failed to fetch ${request.url}: ${error}`);
	}
}

worker.addEventListener('fetch', (event) => {
	const { request } = event;

	if (request.method !== 'GET' || request.headers.has('range')) {
		return;
	}

	const url = new URL(request.url);

	// Don't handle data URIs
	const isHttp = url.protocol.startsWith('http');
	const isDevServerRequest =
		url.hostname === self.location.hostname && url.port !== self.location.port;
	const skipUncachedRequests = request.cache === 'only-if-cached' && !isStaticAsset;

	if (isHttp && !isDevServerRequest && !skipUncachedRequests) {
		event.respondWith(serve(request));
	}
});

// Register a background sync task for failed requests
worker.addEventListener('sync', (event) => {
	if (event.tag === 'syncFailedRequests') {
		event.waitUntil(processFailedRequests());
	}
});

async function processFailedRequests() {
	const db = await openDatabase();
	const tx = db.transaction('failedRequests', 'readwrite');
	const store = tx.objectStore('failedRequests');
	const requests = await store.getAll();
	await Promise.all(
		requests.map(async ({ method, url, headers, body }) => {
			try {
				const response = await fetch(url, {
					method,
					headers: new Headers(JSON.parse(headers)),
					body
				});
				if (response.ok) {
					await store.delete(id);
				}
			} catch (error) {
				console.error(`Failed to retry request ${id}: ${error}`);
			}
		})
	);
	await tx.complete;
}

async function storeFailedRequest(request) {
	const { method, url, headers, body } = request;
	const db = await openDatabase();
	const tx = db.transaction('failedRequests', 'readwrite');
	const store = tx.objectStore('failedRequests');
	await store.add({ method, url, headers: headers.toJSON(), body });
	await tx.complete;
}

async function openDatabase() {
	return new Promise((resolve, reject) => {
		const request = indexedDB.open('failedRequests', 1);

		request.onerror = (event) => reject(event.target.error);
		request.onsuccess = (event) => resolve(event.target.result);

		request.onupgradeneeded = (event) => {
			const db = event.target.result;
			db.createObjectStore('failedRequests', { autoIncrement: true });
		};
	});
}

function registerSyncTask() {
	navigator.serviceWorker.ready.then((registration) =>
		registration.sync.register('syncFailedRequests')
	);
}

worker.addEventListener('fetch', (event) => {
	const { request } = event;

	if (request.method === 'POST' && !request.url.includes('/rentals')) {
		event.respondWith(
			fetch(request).catch(() => {
				storeFailedRequest(request.clone());
				registerSyncTask();
			})
		);
	}
});
